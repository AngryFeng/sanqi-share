# Linux虚拟内存

## 1.理解虚拟内存概念

线程为计算机系统中的基本执行单位，进程为**基本资源单位**，每个进程都有一个内存地址空间用于存放当前进程的一些共享数据。当进程启动时会申请一定大小的内存，但是这里的内存不是实际的物理内存地址，不直接定位物理内存；而是一块虚拟内存空间，内核会在进程地址空间中的虚拟地址空间和物理地址空间做一个**映射**来达到访问物理内存的目的。

虚拟内存也就是一中**内存管理技术**，它为进程提供了一个独立的、连续的地址空间，让进程误以为自己拥有一块完整且足够大的内存空间，而无需关心实际物理内存的具体布局和大小限制。它的主要作用之一就是**实现了内存地址转换**，每个进程都有自己的虚拟内存地址空间，这个空间通过**页表**与物理内存进行映射；而页表就像是一本地址翻译字典，负责将进程使用的虚拟地址翻译成实际的物理地址。

比如在Java启动参数中“-Xms”指定JVM堆的初始大小是虚拟内存的大小，而非直接对应物理内存的分配

```c
java -jar -Xms1G -Xmx4G xxx.jar    
```

JVM向操作系统申请1GB的虚拟地址空间，物理内存占用可能仅为100Mb（取决于JVM初始化时的实际内存需求）。

## 2.内存地址寻址范围

虚拟空间的大小由处理器架构位数决定，在`x86_64`的64位系统上，理论的内存地址就是16EiB（2^64）的大小，但实现中首硬件架构和操作系统设计的限制，仅部分地址位被有效利用，硬件层面通过符号扩展机制仅支持48位虚拟地址（低48位），高16位填充第47位的执行，形成**规范地址**，而实际可寻址空间为256TB（2^48字节），分成两部分：

- **用户空间范围**：`0x0000000000000000` 到 `0x00007FFFFFFFFFFF`（低128TB）
- **内核空间范围**：`0xFFFF800000000000` 到 `0xFFFFFFFFFFFFFFFF`（高128TB）

Linux 系统默认使用完整的 `48 位地址`，但用户进程实际可用空间通常更小（如通过 `TASK_SIZE_MAX` 限制为 128 TB 减去`保护页`[^1]）

Linux系统中查看`/proc/cpuinfo`时，`address sizes`描述了CPU的物理地址和虚拟地址的寻址能力

```c
$cat /proc/cpuinfo | grep address
address sizes   : 43 bits physical, 48 bits virtual
address sizes   : 43 bits physical, 48 bits virtual
address sizes   : 43 bits physical, 48 bits virtual
address sizes   : 43 bits physical, 48 bits virtual
```

> 物理地址

`43 bits physical`：表示 CPU 可以寻址的物理内存空间大小,决定了 CPU 能直接访问的最大物理内存, 2^43 字节，CPU 理论上最多支持 8 TiB 的物理内存

> 虚拟地址

`48 bits virtual`：表示 CPU 的虚拟地址空间大小。决定了单个进程能使用的最大虚拟内存空间,2^48 字节，每个进程的虚拟地址空间上限为 256 TiB（操作系统通过虚拟内存机制将虚拟地址映射到物理地址或磁盘交换空间）。用户程序与内核共享此空间，但实际可用部分由操作系统分配（如用户空间通常为128TB）。

所以进程`虚拟地址空间的大小`不取决于安装的物理内存大小 `RAM`，而是取决于`处理器架构`，单个进程通常不使用其整个地址空间。其中大部分是未分配的，并且没有映射到任何实际的物理内存。

## 3.虚拟内存工作机制

Linux把虚存空间分成若干个大小相等的**存储分区**，Linux把这样的分区叫做**页**。为了换入、换出的方便，物理内存也就按也得大小分成若干个块。由于物理内存中的块空间是用来容纳虚存页的容器，所以物理内存中的块叫做**页框**。页与页框是Linux实现虚拟内存技术的基础。

### 3.1.虚拟内存中的页&物理内存页框和页表

在Linux中，页和页框的大小一般为4KB。物理内存和虚拟内存被分成了页框和页后，其存储单元原来的地址也就被分成了两段：高段位的页框吗和页码，它们是识别页框和页码的编码；低段位的页框偏移量和页内偏移量，它们是存储单元在页框和页内的地址编码。

![页框&页框偏移量+页码&页码偏移量](.\素材\页框&页框偏移量+页码&页码偏移量.jpg)

为了使系统可以正确的访问虚存页在对应页框中的映像，在把一个页映射到某个页框上的同时，就必须把页码和存放该页映像的页框码填入一个叫做页表的表项中。**这个页表就是映射记录表。**

![页框码&页码映射表——页表](.\素材\页框码&页码映射表——页表.jpg)

也就是说：处理器遇到的地址都是虚拟地址。虚拟地址和物理地址都分成页码（页框码）和偏移值两部分。在由虚拟地址转化成物理地址的过程中，偏移值不变。而页码和页框码之间的映射就在一个映射记录表——页表中。

![寻址页码页框码+偏移量](.\素材\寻址页码页框码+偏移量.jpg)

### 3.2.请页与交换

**虚存页面到物理页框的映射叫做页面的加载**

当处理器试图访问一个虚拟页面时，首先去页表中查询该页是否已映射了物理页框，并记录在页表。如果在，`MMU`会把页码转换成页框码，并加上虚拟地址提供的页内偏移量形成物理地址去访问物理内存。

如果不在则意味着该虚拟页还没有被载入内存，这是`MMU`就会通知操作系统：发生了一个页面访问错误（页面错误），接下来系统会启动**“请页”机制**，会调用相应的系统操作函数，判断该虚拟地址是否为有效地址。

> 请页

如果是有效地址就从虚拟内存中将该地址指向的页面读入到内存中的一个空闲的页框中，并在页表中添加上相对应的表项，最后处理器将从发生页面错误的地方重新开始运行；如果是无效的地址，则表明进程在试图访问一个不存在的虚拟地址，此时操作系统将终止此次访问。

> 交换页

在请页成功后，内存中如果没有空闲的物理页框时，系统就会启动**“交换”机制**，会调用相关的系统操作函数在物理页框中找到一个不再使用或者近期可能不会用到的页面所占据的页框（`LRU`），然后把其中的页移出，移装在新的页面。而对于移出的页面会分两种情况处理：如果页面未被修改过，直接删除；如果页面曾经被修改过，则系统必须将该页写会辅存[^2]。

**系统请页的处理流程**：

![系统请页处理过程](.\素材\系统请页处理过程.jpg)

### 3.3.多级页表

页表是操作系统创建的用于内存管理的表格。因此，一个程序在运行时，其页表也要存放到内存空间。如果一个程序只需要一个页表，则不会有什么问题。但如果，程序的虚拟空间很大的话，就会出现一个比较大的问题。

比如：如果每个进程都分配一个大的页表，64位系统 理论虚拟地址空间为`2^64`字节，但实际 Linux 系统通常采用`48`位有效虚拟地址即`2 ^48`字节(256TB）。若页面大小为4KB(`2^12`字节），则需管理的页表项数量为 `虚拟页数 = 2^48 / 2^12 = 2^36`，每个`页表项`需要存储`物理页帧号（PFN）和权限标志`，通常占用`8字节`。所以页表的总内存需求为： `总大小 = 2^36 × 8 = 2^39 字节 = 512GB`。

512G ，即一个进程的页表本身就是巨大的，如果多个进程更夸张，但是实际中进程仅使用少量内存（如1GB），可能只需要几个映射，单级页表仍需预分配全部虚拟地址空间对应的页表项，造成大部分的空间浪费，况且也没有那么多内存存放页表。

所以，最好对页表也进行分页存储，在程序运行时只把需要的页复制到内存，而暂时不需要的页就让它留在辅存中。为了管理这些页表页，还要建立一个记录页表页首地址的页目录表，于是单级页表就变成了二级页表。二级页表的地址转换如下图所示：

![多级页表转换](.\素材\多级页表转换.jpg)

当然，如果程序的虚拟空间更大，那么也可以用三级页表来管理。为了具有通用性，Linux系统使用了三级页表结构：页目录（Page Directory，PGD）、中间页目录（Page Middle Directory，PMD）、页表（Page Table，PTE）。

为了通用，Linux系统使用了三级页表结构：页目录、中间页目录和页表。PGD为顶级页表，是一个pgd_t数据类型（定义在文件linux/include/page.h中）的数组，每个数组元素指向一个中间页目录；PMD为二级页表，是一个pmd_t数据结构的数组，每个数组元素指向一个页表；PTE则是页表，是一个pte_t数据类型的数组，每个元素中含有物理地址。

![多级页表地址映射](.\素材\多级页表地址映射.jpg)

### 3.4.快表

在系统每次访问虚存页时，都要在内存的所有页表中寻找该页的页框，这是一个**很费时间**的工作。但是，人们发现，系统一旦访问了某一个页，那么系统就会在一段时间内稳定地工作在这个页上。所以，为了提高访问页表的速度，系统还配备了一组正好能容纳一个页表的硬件寄存器，这样当系统再访问虚存时，就首先到这组硬件寄存器中去访问，系统速度就快多了。这组存放当前页表的寄存器叫做**快表**。

MMU访存工作过程如下图所示：

![MMU工作流程](.\素材\MMU工作流程.jpg)





































[^1]:**保护页**是Linux内核在用户空间与内核空间之间预留的**未映射内存区域**，用于阻止用户程序越界访问内核内存。x86_64架构的48位虚拟地址（256TB）需扣除保护页占用的部分地址，因此实际可用空间略小于理论值。其本质是安全隔离机制，通过触发页错误终止非法访问，保护系统稳定
[^2]:**虚拟内存交换机制（脏页处理）：**把脏页存储到硬盘交换区；页表标记该页不在内存并记录交换区位置