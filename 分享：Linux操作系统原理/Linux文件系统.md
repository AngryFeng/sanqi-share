# Linux文件系统

## 1.文件使用中的怪事

- Q1：传输文件时，为什么打包文件比分开文件快？

![未压缩前复制文件](.\素材\分开复制文件.png)

![未压缩前复制文件](.\素材\打包复制文件.png)

- Q2：为什么文件大小和占用空间大小不一致？

![文件大小和实际占用空间大小不一致](.\素材\文件大小和实际占用空间大小不一致.png)

- Q3：为什么文件大小和占用空间大小一致？

![文件大小和占用空间一致](.\素材\文件大小和占用空间一致.png)

- Q4：1Tb的硬盘，为什么“缺斤少两”

![硬盘大小缺斤少两](.\素材\硬盘大小缺斤少两.png)

## 2.文件系统概述

存储是现代操作系统的重要功能之一，文件系统（File System）是计算机管理存储设备中数据的核心机制，它定义了数据如何被组织、存储和访问。简单来说，文件系统是用户与物理存储介质（如硬盘、SSD）之间的“翻译官”，将底层复杂的存储操作抽象为文件、目录等逻辑概念，使程序能够通过统一接口高效读写数据。

### 2.1 存储介质-“块设备”

存储介质是计算机持久化数据的物理载体，其技术演进直接影响存储性能与可靠性。常见的存储介质有：机械硬盘、固态硬盘、光盘、磁带、闪存设备。不同存储介质在**容量**、**速度**、**成本**和**耐久性**上各有取舍。HDD与SSD作为主流块设备，是文件系统的主要载体；而磁带、光盘等则用于特定场景（如备份、分发）。理解介质特性，可帮助开发者合理规划存储架构。

#### 2.1.1 块设备分类

> 机械硬盘

![块设备](.\素材\块设备-机械硬盘.png)

- 物理结构
  - 由多个高速旋转的磁性盘片（Platter）组成，每个盘片表面覆盖磁性材料，数据通过磁头（Read/Write Head）读写。
  - 磁头固定在可移动的机械臂（Actuator Arm）上，通过移动磁头到指定磁道（Track）和扇区（Sector）定位数据。
- 工作机制
  - **寻道时间（Seek Time）**：磁头移动到目标磁道的时间。
  - **旋转延迟（Rotational Latency）**：盘片旋转到目标扇区的等待时间。
  - **数据传输**：磁头通过磁场变化读取磁性颗粒的极性（0/1）。

> 固态硬盘

![块设备-固态硬盘](.\素材\块设备-固态硬盘.png)

- 物理结构
  - 基于NAND闪存芯片，数据存储在浮栅晶体管（Floating Gate Transistor）中，通过电荷有无表示0/1。
  - 基本单元为**页（Page，通常4KB）**，多个页组成**块（Block，通常512KB~4MB）**。
- 工作机制
  - **电子寻址**：通过控制器直接访问存储单元，无机械运动，寻址时间极短（微秒级）。
  - **写入限制**：需先擦除整个块再写入，且每个存储单元有擦写次数限制（P/E Cycle）。
  - **磨损均衡（Wear Leveling）**：控制器动态分配写入位置，避免局部单元过度损耗。

结合不同存储介质的物理特性和工作原理，无论是机械硬盘HDD还是固态硬盘SSD，操作系统均以固定大小的数据块为基本单元进行读写，而非直接操作单个字节。基于此特性操作系统将这些存储设备抽象为**块设备（blockdevice）**，以方便文件系统使用统— 的接口访问。

#### 2.1.2 最小单位“块”

在文件系统中，“块”（Block）是数据存储和分配的最小逻辑单位。块设备上的存储空间在逻辑上被划分成固定大小的存储块（block）。

![块的大小](.\素材\块的大小.png)

文件块大小的设定直接影响存储效率、性能及空间利用率，其设计需权衡硬件特性与应用场景。

- **逻辑块**：操作系统对存储设备进行读写操作的基本单元，通常为 **4KB**（现代系统常见值），但可配置为512B、8KB等。
- **物理块**：存储介质的实际操作单元（如HDD的扇区、SSD的页），逻辑块需与物理块对齐以避免性能损失。

> 常见文件系统的块大小

- **ext4（Linux）**：默认4KB，支持1KB~64KB；
- **NTFS（Windows）**：默认4KB，支持512B~64KB；
- **APFS（macOS）**：固定4KB，通过克隆写入（Copy-on-Write）优化碎片问题；
- **ZFS**：支持动态块大小（512B~1MB），根据文件类型自动调整。

> 块号

每个存储块均有一个地址，被称为**块号**。文件系统在请求中指定块号，操作系统负责对块设备中的指定块进行数据写入和读取

#### 2.1.3 Linux存储软件栈

![Linux存储软件栈](.\素材\Linux存储软件栈.png)

从用户程序到硬件:Linux通过分层软件栈将用户对文件的抽象操作转化为存储设备的物理I/O，各层职责明确且相互协作。以下是核心层次及其作用：

**1. 用户程序（User Application）**

- **行为**：通过`read()`/`write()`等系统调用或标准库（如`fread()`）发起文件读写请求。
- **关键点**：用户程序仅感知文件路径、偏移量和数据长度，无需关心底层存储细节。

**2. 虚拟文件系统（VFS, Virtual File System）**

- **作用**：统一不同文件系统（ext4、XFS等）的接口，提供通用的文件操作抽象（如`inode`、`dentry`）。
- **示例**：用户调用`open("/data/file.txt")`时，VFS解析路径并确定目标文件系统类型。

**3. 页缓存（Page Cache）**

- **功能**：缓存文件数据（以内存页为单位），减少直接访问磁盘的次数。
- **写回策略**：延迟写入（数据先写入内存，由内核线程`pdflush`异步刷盘）。

**4.文件系统**

- **职责**：处理文件元数据（如权限、时间戳）、数据块分配（如ext4的extent树）。
- **流程**：若数据在页缓存中命中，直接返回；若未命中，触发I/O请求从磁盘读取。

**5. I/O调度器（I/O Scheduler）**

- **目标**：优化I/O请求顺序，减少存储设备的寻址开销（尤其针对HDD）。
- 常见调度策略：
  - **CFQ（Completely Fair Queuing）**：为每个进程分配公平的I/O带宽，适合HDD。
  - **Deadline**：确保请求在截止时间内完成，避免饥饿。
  - **NOOP**：仅合并相邻请求，不排序（适合SSD或高速存储设备）。

**6. 设备驱动（Device Driver）**

- **作用**：将逻辑I/O请求（如“读取块号1024~2048”）转换为硬件指令（如SCSI命令）。
- 关键机制：
  - **DMA（Direct Memory Access）**：允许设备直接与内存交换数据，减少CPU占用。
  - **中断处理**：设备完成I/O后通过中断通知CPU。

**7. 存储设备（Block Device）**

- **执行**：根据驱动下发的指令读写物理块（如HDD的扇区、SSD的页）。
- **反馈**：将数据或状态码（成功/失败）通过驱动层逐级返回至用户程序。

### 2.2 文件

**文件（File）**是文件系统中数据管理的核心抽象，它是用户视角下存储信息的最小逻辑单元。无论是文本、图片、可执行程序，还是设备接口，操作系统均以文件形式统一管理。

#### 2.2.1 文件的本质

DS：文件是存储在存储介质上的**命名数据集合**，由元数据（描述信息）和用户数据（内容）共同构成。

《操作系统：实现与原理》：**文件实质上是一个有名字的字符序列**。

![文本文件](.\素材\文本文件.png)

![pdf文件](.\素材\pdf文件.png)

![mp3文件](.\素材\mp3文件.png)

#### 2.2.2 “文件”的构成

> 元数据（file metadata）：

- **文件名**：用户可识别的唯一标识（如`report.pdf`）。
- **属性**：大小、权限、时间戳（创建/修改/访问时间）、所有者等。
- **存储位置**：通过`inode`（Linux）或`MFT条目`（NTFS）记录数据块的物理地址。

> 文件数据（file data）：

- 实际内容（如文本字节、二进制代码），按文件系统块大小分割存储。

### 2.3 文件系统

文件系统是操作系统用于**管理存储设备**（如硬盘、SSD）上数据存储与访问的机制，定义了文件的命名、组织、存储及检索规则实现文件接口并负责**管理文件数据和元数据**的系统即为文件系统

#### 2.3.1 文件系统定位

文件系统是文件的管理者，向上提供文件的抽象并实现访问文件的接口（如VFS），向下管理物理存储。

#### 2.3.2 常见的文件系统

| **文件系统** | **实现方式**                         | **适用操作系统**         | **关键特点**                                       |
| :----------- | :----------------------------------- | :----------------------- | :------------------------------------------------- |
| **NTFS**     | 基于**主文件表（MFT）**的表格结构    | Windows                  | 日志、权限、硬链接/符号链接支持，单文件最大256TB。 |
| **FAT32**    | 基于**文件分配表（FAT）**的链式结构  | 跨平台（U盘/嵌入式）     | 兼容性强，无日志，单文件最大4GB。                  |
| **exFAT**    | 改进的**扩展文件分配表（exFAT）**    | 跨平台（大容量移动存储） | 支持大文件（单文件16EB），无日志。                 |
| **ext4**     | **inode + 块位图**结构，支持extent树 | Linux                    | 日志、大文件（单文件16TB）、延迟分配。             |
| **APFS**     | **B-tree + 写时复制（COW）**         | macOS/iOS                | 快照、加密、空间共享，针对闪存优化。               |

## 3.基于`inode`的文件系统

### 3.1 简单文件结构

Q&A：文件由元数据+数据组成；块设备是以**特定单位大小（4K）**的块连续构建组成的集合，作为文件系统需要如何构建数据结构存储一个文件？

![简单结构直接存放文件](.\素材\简单结构直接存放文件..png)

构建结构体直接存放元数据+数据内容。根据**文件元数据+数据**内容大小直接申请连续块数量，先存放元数据，接着存放数据。

### 3.2 `inode`与文件

![文件直接存放结构问题](.\素材\文件直接存放结构问题..png)

Q&A：以上创建的存储一个文件的简单数据结构，如何应对修改特别频繁的文件需求，如何优化数据结构管理更高效？

文件直接存放结构问题：需要连续空闲空间；文件数据修改不便；结构体体量过大。

#### 3.2.1 数据直接索引方式

![文件索引节点](.\素材\文件索引节点..png)

**`inode`结构，通过固定元数据+数据块索引方式管理文件的元数据+数据。**

Q&A：通过直接索引的方式管理数据块，当出现大文件时会有何问题？大文件小文件如何兼顾？

![文件直接索引结构大文件问题](.\素材\文件直接索引结构大文件问题.png)

#### 3.2.2 数据分级索引方式

![文件间接索引结构](.\素材\文件间接索引结构.png)

类似虚拟内存中提到的页表，在`inode`中采用分级的方式来组织存储块号。

#### 3.2.3 inode节点构成

![inode结构](.\素材\inode结构.png)

> 直接索引/一级索引/二级索引

`inode`中保存了三种存储指针（即存储设备的块号）：

1. 第— 种指针为直接指针，其直接指向数据块，数据块中保存了文件数据；
2. 第二种指针为间接指针，指向一个一级索引块，—级索引块中存放着指向数据块的指针；
3. 第三种指针为二级间接指针，指向—个二级索引块，二级索引块中的每个指针均指问一个一级索引块，进而指向多个数据块。

> 能表示的文件大小范围

我们之后均假设块大小为4KB，每个指针占据8个字节，每个`inode`中直接指针有12个，间接指针有3个，二级间接指针有1个。一个`inode`结构最大能表示多大的文件：

- 12个直接指针，每个指向4K，总共48K
- 每个指针8字节，索引块4K大小，总共有512个指针；一个索引块能表示4Kx512=2M数据，3个一级间接指针能表示3*2M=6M数据
- 1个二级间接指针，指向二级索引块，表示2M*512=1G数据
- 48K + 6M + 1G
- 多级指针比例是可调的，如果减少一个一级间接指针，增加一个三级指针呢？

> inode节点占用空间&索引占用空间

文件系统模块存放的时`inode`节点，也就是"元数据+指针"=128字节+128字节=256字节。

存满一个1G的文件，实际需要多大空间：

- `inode`结构体256字节
- 3个一级间接指针指向三个索引数据块：3*4K=12K
- 1个二级间接指针指向521个索引数据块：1K+512*4K=1K+2M
- 256字节+13K+2M+1G

> `inode`和内存页表有何相似之处？

如果我们把文件看成一个虚拟地扯空间（4GB的文件就是0～4GB的空间），把硬盘看作物理地址空间（4TB的硬盘就是0～4TB的空间），那么对文件某个偏移量的访问：首先需要将该偏移量翻译成硬盘空间的地址，这个过程与虚拟内存地址翻译的过程十分相似，而`inode`则担任了页表的角色，负责两个地址空间之间的映射。

> Ask Q1 Q2/Q3

> `EXT4`文件系统优化

使用`inode`结构存储满文件时，对于文件数据块是使用指针去索引的，**文件越大需要维护的数据块指针就越多**；以数据块为单位分块多级索引的方式也存在**数据存储分散导致随机访问性能下降**的问题。`EXT4`文件系统针对该情况设计了**区段树**。

![Ext4文件存储-区段树](.\素材\Ext4文件存储-区段树.png)

> 文件元数据信息

| **元数据字段**    | **描述**                                                     |
| :---------------- | :----------------------------------------------------------- |
| **i_mode**        | 文件类型（普通文件、目录等）及权限（rwx）。                  |
| **i_uid**         | 文件所有者的用户ID。                                         |
| **i_gid**         | 文件所属组的组ID。                                           |
| **i_size**        | 文件大小（字节）。                                           |
| **i_atime**       | 最后访问时间（Access Time）。                                |
| **i_mtime**       | 最后修改时间（Modify Time，指文件内容变更）。                |
| **i_ctime**       | 最后状态变更时间（Change Time，指元数据变更，如权限、链接数）。 |
| **i_links_count** | 硬链接计数（删除文件需此值为0）。                            |
| **i_blocks**      | 文件占用的磁盘块数（每块通常为4KB）。                        |
| **i_block[]**     | 数据块指针数组（直接块、间接块指针，用于定位文件内容）。     |
| **i_flags**       | 文件标志（如不可修改、压缩、加密等）。                       |
| **i_generation**  | 文件版本号（用于NFS等网络文件系统防重复）。                  |

> 文件类型

通过`i_mode`字段的高4位标识文件类型，常见类型如下：

| **文件类型**     | **标识符（宏）** | **说明**                                 |
| :--------------- | :--------------- | :--------------------------------------- |
| **普通文件**     | `S_IFREG`        | 文本、二进制等用户数据文件。             |
| **目录**         | `S_IFDIR`        | 包含子文件和子目录的特殊文件。           |
| **符号链接**     | `S_IFLNK`        | 指向其他文件路径的快捷方式。             |
| **字符设备文件** | `S_IFCHR`        | 提供流式访问的设备（如终端`/dev/tty`）。 |
| **块设备文件**   | `S_IFBLK`        | 提供块级访问的设备（如磁盘`/dev/sda`）。 |
| **管道（FIFO）** | `S_IFIFO`        | 进程间通信的命名管道。                   |
| **套接字**       | `S_IFSOCK`       | 网络通信的套接字文件。                   |

### 3.2 目录&文件

#### 3.2.1 文件名与目录

Q&A：文件系统管理文件时，需要文件名吗？

文件与`inode`是一一对应的，对于计算机程序来说，通过`inode`号就可以 找到对应的文件。`inode`编号是给操作系统看的，而文件名是给人看的。所以`inode`的元数据中**没有文件名**。

然而对于用户来说，使用`inode`号作为文件名并不合适。在文件系统中加入字符串形式的文件名，利用**目录**增加一层从文件名字符串到`inode`号之间的映射。

#### 3.2.2 重新认识“目录”

![目录tree结构](.\素材\目录tree结构.png)

#### 3.2.3 目录与文件的关系

目录是一种**特殊类型的文件**，用于记录其他文件和子目录的元数据（如名称、inode指针），形成树状层次结构。

文件名用于区分不同的文件，**保存在目录中**。就书籍的 “目录”—样，目录将文件名（对应书籍中各章节的标题）**组织**在—起，并且记录了每个文件名对应的**文件地址或者编号**（对应书籍中的页码）。每个文件名和对应的文件地址或编号组成一个**目录项**，一个或多个目录项组成一个目录。

**文件不是直接存放在目录中，而是把“文件名”、“文件地址”、“文件编号”组成目录项，存放在目录下。**

由于目录本身也是文件，因此可以通过**递归**的方式层次化地组织文件系统中的所有 文件。换句话说，目录与普通文件一样也有文件名，**其文件名保存在上一层目录文件中**； 上一层目录的文件名则保存在更上一层目录文件中，一直递归到最高一层目录——根目 录。**根目录没有文件名**，因为已经没有更上一层目录了。文件系统并不通过文件名来找到根目录，而是**将第一个`inode`作为根目录文件**。

#### 3.2.4 目录项结构

与常规文件中保存的用户数据不同，目录中保存的是—种特殊的结构──目录项。 每个目录项代表—条文件信息，记录了文件的文件名及其对应的`inode`号。

![目录项结构](.\素材\目录项结构.png)

一个目录项内的结构，包括文件名、文件名的长度、文件名对应的`inode`号和整个目录项的长度。

- 目录项长度记录整个目录项的长度，为目录项删除和重用而设计
- 文件名长度记录后面保存的文件名的有效长度

#### 3.2.5 目录下的文件操作

- 在目录中查找文件：在目录中查找某个文件名时，文件系统从目录文件的数据块中记录的第一个目录项开始依次比较，当某个目录项中的文件名与要查找的文件名相同时，返回对应的`inode`号。由于只需要查找当前目录保存的目录项，所以查找时间远小于遍历文件系统`inode`表的时间。 
- 遍历目录：与查找文件名的过程类似，文件系统找到该目录文件的数据块，依次检查保存的所有有效(还未被删除)的目录项，并返回结果。
- 删除目录项：文件系统首先在该目录中找到这个文件，然后从目录中删除对应的目录项。一种常见的实现方法是将目录项中的`inode`号设为0，表示该目录项是无效的。这种方法无须为目录有效性信息预留额外的存储空间，可以更高效地利用 空间。同时，删除后还可以将相邻的无效目录项进行合并，以允许更长的新目录项重新利用这些空间。
- 新增目录项：在目录中创建新文件时，文件系统会在该目录中增加一个新的目录项，记录新文件的文件名和对应的`inode`号。为优化存储空间，如果目录文件中有无效(已被删除)的目录项，且该目录项的空间足够保存新文件的文件名，则可以重用此目录项的位置存放新的目录项。如果找不到合适的无效目录项，则新的目录项会以追加的方式记录在目录文件末尾。

#### 3.2.6 一个文件可以有多个文件名

> 符号链接（软链接）

![软连接](.\素材\软链接.png)

> 硬连接

![硬链接](.\素材\硬链接.png)

### 3.3 文件描述符&打开文件&inode关系

![文件描述符&打开文件句柄&inode关系图](.\素材\文件描述符&打开文件句柄&inode关系图.png)

每一个文件描述符会与一个打开文件相对应，同时，不同的文件描述符也会指向同一个文件。相同的文件可以被不同的进程打开也可以在同一个进程中被多次打开。系统为每一个进程维护了一个文件描述符表，该表的值都是从0开始的，所以在不同的进程中你会看到相同的文件描述符，这种情况下相同文件描述符有可能指向同一个文件，也有可能指向不同的文件。

```c
/*
操作系统内核维护的数据结构
文件描述符（File Descriptor）-[进程级的文件描述符表]
打开文件表项（struct file）-[系统级的打开文件描述符表]
inode-[文件系统的inode表]
*/
```

### 3.4 文件系统存储布局

文件系统以特定的存储布局将文件数据和文件数据保存在存储设备之中。为了高效地管理这些文件数据和元数据，文件系统通常将存储空间划分成不同区域，分别用于不同功能。

> 总分区存储布局

![inode文件系统总分区存储布局](.\素材\inode文件系统总分区存储布局.png)

#### 3.4.1 基于`inode`文件系统的存储布局

![基于inode文件系统的存储布局](.\素材\基于inode文件系统的存储布局.png)

>  超级块

超级块位于文件系统的第一个存储块，负责记录整个文件系统的全局信息，主要包括其他区域在存储中的位置，即**每个区域开始的存储块号**。在真实的文件系统中，超级块通常还会包含用于**标识文件系统类型的魔数**、版本信息、**存储的空间大小**、**能支持的最大`inode`数量**、**当前空闲可用的`inode`的数量**、能支持的最大的块数量、**当前空闲可用的块数量**，以及一些统计信息，如最近一次的挂载 时间等。同时，由于超级块中包含的信息非常重要，通常会在存储设备的不同区域保存多个备份。

> 块分配信息

bitmap结构，用位图表示对应的节点是否使用

> `inode`分配信息

bitmap结构，用位图表示对应的节点是否使用

> inode节点表

保存所有的`inode`结构，由于`inode`表的区域不能动态调整，因此文件系统所能保存的最大文件数量在格式化的时候就已经确定了。

> 数据块

真正存储文件数据区域，不仅保存普通文件的数据，还会保存`inode`的索引块，以及目录的数据。

> 文件系统“额外消耗” Ask Q4

以上块信息中，数据块大小：4K * 234,159,616 = 937G

`inode`节点表：256B * 58,540,032 = 15G

`inode`分配信息：58,540,032 / 8 = 7.3M

块分配信息：234,159,616 / 8 = 29.3M

![硬盘缺斤少两答案](.\素材\硬盘缺斤少两答案.png)

## 4.基于TABLE的文件系统

### 4.1 FAT

#### 4.1.1 存储布局

#### 4.1.2 目录项结构

#### 4.1.3 目录分配表FAT

#### 4.1.4 瓶颈分析

#### 4.1.5 exFAT

### 4.2 NTFS

#### 4.2.1 存储布局

#### 4.2.2 主文件表MTF

#### 4.2.3 数据保存位置

#### 4.2.4 对比优势

## 5.虚拟文件系统VFS

### 5.1 问题背景

异构的文件系统

屏蔽文件系统的异构性

### 5.2 VFS实现

#### 5.2.1 抽象层

> 操作系统层面

VFS调用接口操作&管理文件

> 文件系统驱动软件层面

文件系统驱动软件实现VFS接口，进行“翻译”，操作硬件

#### 5.2.2 文件系统挂载

#### 5.2.3 用户程序操作文件







## 结尾

参考资料url

https://ipads.se.sjtu.edu.cn/ospi/

https://ycnw11in464y.feishu.cn/file/IO2QbAiMFo0XnWx0lqyc9DaunBe

https://ycnw11in464y.feishu.cn/file/SXm8bcUrIobU3bxLWY4cpmn7n66

https://ipads.se.sjtu.edu.cn/courses/os/2020/slides/OS-12-fs.pdf

https://blog.csdn.net/cywosp/article/details/38965239
