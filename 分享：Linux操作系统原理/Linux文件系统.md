# Linux文件系统

## 1.文件使用中的怪事

- Q1：传输文件时，为什么打包文件比分开文件快？

![未压缩前复制文件](.\素材\分开复制文件.png)

![未压缩前复制文件](.\素材\打包复制文件.png)

- Q2：为什么文件大小和占用空间大小不一致？

![文件大小和实际占用空间大小不一致](.\素材\文件大小和实际占用空间大小不一致.png)

- Q3：为什么文件大小和占用空间大小一致？

![文件大小和占用空间一致](.\素材\文件大小和占用空间一致.png)

- Q4：1Tb的硬盘，为什么“缺斤少两”

![硬盘大小缺斤少两](.\素材\硬盘大小缺斤少两.png)

## 2.文件系统概述

存储是现代操作系统的重要功能之一，文件系统（File System）是计算机管理存储设备中数据的核心机制，它定义了数据如何被组织、存储和访问。简单来说，文件系统是用户与物理存储介质（如硬盘、SSD）之间的“翻译官”，将底层复杂的存储操作抽象为文件、目录等逻辑概念，使程序能够通过统一接口高效读写数据。

### 2.1 存储介质-“块设备”

存储介质是计算机持久化数据的物理载体，其技术演进直接影响存储性能与可靠性。常见的存储介质有：机械硬盘、固态硬盘、光盘、磁带、闪存设备。不同存储介质在**容量**、**速度**、**成本**和**耐久性**上各有取舍。HDD与SSD作为主流块设备，是文件系统的主要载体；而磁带、光盘等则用于特定场景（如备份、分发）。理解介质特性，可帮助开发者合理规划存储架构。

#### 2.1.1 块设备分类

> 机械硬盘

![块设备](.\素材\块设备-机械硬盘.png)

- 物理结构
  - 由多个高速旋转的磁性盘片（Platter）组成，每个盘片表面覆盖磁性材料，数据通过磁头（Read/Write Head）读写。
  - 磁头固定在可移动的机械臂（Actuator Arm）上，通过移动磁头到指定磁道（Track）和扇区（Sector）定位数据。
- 工作机制
  - **寻道时间（Seek Time）**：磁头移动到目标磁道的时间。
  - **旋转延迟（Rotational Latency）**：盘片旋转到目标扇区的等待时间。
  - **数据传输**：磁头通过磁场变化读取磁性颗粒的极性（0/1）。

> 固态硬盘

![块设备-固态硬盘](.\素材\块设备-固态硬盘.png)

- 物理结构
  - 基于NAND闪存芯片，数据存储在浮栅晶体管（Floating Gate Transistor）中，通过电荷有无表示0/1。
  - 基本单元为**页（Page，通常4KB）**，多个页组成**块（Block，通常512KB~4MB）**。
- 工作机制
  - **电子寻址**：通过控制器直接访问存储单元，无机械运动，寻址时间极短（微秒级）。
  - **写入限制**：需先擦除整个块再写入，且每个存储单元有擦写次数限制（P/E Cycle）。
  - **磨损均衡（Wear Leveling）**：控制器动态分配写入位置，避免局部单元过度损耗。

结合不同存储介质的物理特性和工作原理，无论是机械硬盘HDD还是固态硬盘SSD，操作系统均以固定大小的数据块为基本单元进行读写，而非直接操作单个字节。基于此特性操作系统将这些存储设备抽象为**块设备（blockdevice）**，以方便文件系统使用统— 的接口访问。

#### 2.1.2 最小单位“块”

在文件系统中，“块”（Block）是数据存储和分配的最小逻辑单位。块设备上的存储空间在逻辑上被划分成固定大小的存储块（block）。

![块的大小](.\素材\块的大小.png)

文件块大小的设定直接影响存储效率、性能及空间利用率，其设计需权衡硬件特性与应用场景。

- **逻辑块**：操作系统对存储设备进行读写操作的基本单元，通常为 **4KB**（现代系统常见值），但可配置为512B、8KB等。
- **物理块**：存储介质的实际操作单元（如HDD的扇区、SSD的页），逻辑块需与物理块对齐以避免性能损失。

> 常见文件系统的块大小

- **ext4（Linux）**：默认4KB，支持1KB~64KB；
- **NTFS（Windows）**：默认4KB，支持512B~64KB；
- **APFS（macOS）**：固定4KB，通过克隆写入（Copy-on-Write）优化碎片问题；
- **ZFS**：支持动态块大小（512B~1MB），根据文件类型自动调整。

> 块号

每个存储块均有一个地址，被称为**块号**。文件系统在请求中指定块号，操作系统负责对块设备中的指定块进行数据写入和读取

#### 2.1.3 Linux存储软件栈

![Linux存储软件栈](.\素材\Linux存储软件栈.png)

从用户程序到硬件:Linux通过分层软件栈将用户对文件的抽象操作转化为存储设备的物理I/O，各层职责明确且相互协作。以下是核心层次及其作用：

**1. 用户程序（User Application）**

- **行为**：通过`read()`/`write()`等系统调用或标准库（如`fread()`）发起文件读写请求。
- **关键点**：用户程序仅感知文件路径、偏移量和数据长度，无需关心底层存储细节。

**2. 虚拟文件系统（VFS, Virtual File System）**

- **作用**：统一不同文件系统（ext4、XFS等）的接口，提供通用的文件操作抽象（如`inode`、`dentry`）。
- **示例**：用户调用`open("/data/file.txt")`时，VFS解析路径并确定目标文件系统类型。

**3. 页缓存（Page Cache）**

- **功能**：缓存文件数据（以内存页为单位），减少直接访问磁盘的次数。
- **写回策略**：延迟写入（数据先写入内存，由内核线程`pdflush`异步刷盘）。

**4.文件系统**

- **职责**：处理文件元数据（如权限、时间戳）、数据块分配（如ext4的extent树）。
- **流程**：若数据在页缓存中命中，直接返回；若未命中，触发I/O请求从磁盘读取。

**5. I/O调度器（I/O Scheduler）**

- **目标**：优化I/O请求顺序，减少存储设备的寻址开销（尤其针对HDD）。
- 常见调度策略：
  - **CFQ（Completely Fair Queuing）**：为每个进程分配公平的I/O带宽，适合HDD。
  - **Deadline**：确保请求在截止时间内完成，避免饥饿。
  - **NOOP**：仅合并相邻请求，不排序（适合SSD或高速存储设备）。

**6. 设备驱动（Device Driver）**

- **作用**：将逻辑I/O请求（如“读取块号1024~2048”）转换为硬件指令（如SCSI命令）。
- 关键机制：
  - **DMA（Direct Memory Access）**：允许设备直接与内存交换数据，减少CPU占用。
  - **中断处理**：设备完成I/O后通过中断通知CPU。

**7. 存储设备（Block Device）**

- **执行**：根据驱动下发的指令读写物理块（如HDD的扇区、SSD的页）。
- **反馈**：将数据或状态码（成功/失败）通过驱动层逐级返回至用户程序。

### 2.2 文件

**文件（File）**是文件系统中数据管理的核心抽象，它是用户视角下存储信息的最小逻辑单元。无论是文本、图片、可执行程序，还是设备接口，操作系统均以文件形式统一管理。

#### 2.2.1 文件的本质

DS：文件是存储在存储介质上的**命名数据集合**，由元数据（描述信息）和用户数据（内容）共同构成。

《操作系统：实现与原理》：**文件实质上是一个有名字的字符序列**。

![文本文件](.\素材\文本文件.png)

![pdf文件](.\素材\pdf文件.png)

![mp3文件](.\素材\mp3文件.png)

#### 2.2.2 “文件”的构成

> 元数据（file metadata）：

- **文件名**：用户可识别的唯一标识（如`report.pdf`）。
- **属性**：大小、权限、时间戳（创建/修改/访问时间）、所有者等。
- **存储位置**：通过`inode`（Linux）或`MFT条目`（NTFS）记录数据块的物理地址。

> 文件数据（file data）：

- 实际内容（如文本字节、二进制代码），按文件系统块大小分割存储。

### 2.3 文件系统

文件系统是操作系统用于**管理存储设备**（如硬盘、SSD）上数据存储与访问的机制，定义了文件的命名、组织、存储及检索规则实现文件接口并负责**管理文件数据和元数据**的系统即为文件系统

#### 2.3.1 文件系统定位

文件系统是**文件的管理者**，向上提供文件的抽象并实现访问文件的接口（如VFS），向下管理物理存储。

#### 2.3.2 常见的文件系统

| **文件系统** | **实现方式**                         | **适用操作系统**         | **关键特点**                                       |
| :----------- | :----------------------------------- | :----------------------- | :------------------------------------------------- |
| **NTFS**     | 基于**主文件表（MFT）**的表格结构    | Windows                  | 日志、权限、硬链接/符号链接支持，单文件最大256TB。 |
| **FAT32**    | 基于**文件分配表（FAT）**的链式结构  | 跨平台（U盘/嵌入式）     | 兼容性强，无日志，单文件最大4GB。                  |
| **exFAT**    | 改进的**扩展文件分配表（exFAT）**    | 跨平台（大容量移动存储） | 支持大文件（单文件16EB），无日志。                 |
| **ext2/3/4** | **inode + 块位图**结构，支持extent树 | Linux                    | 日志、大文件（单文件16TB）、延迟分配。             |
| **APFS**     | **B-tree + 写时复制（COW）**         | macOS/iOS                | 快照、加密、空间共享，针对闪存优化。               |

## 3.基于`inode`的文件系统

### 3.1 简单文件结构

Q&A：文件由元数据+数据组成；块设备是以**特定单位大小（4K）**的块连续构建组成的集合，作为文件系统需要如何构建数据结构存储一个文件？

![简单结构直接存放文件](.\素材\简单结构直接存放文件.png)

构建结构体直接存放元数据+数据内容。根据**文件元数据+数据**内容大小直接申请连续块数量，先存放元数据，接着存放数据。

### 3.2 `inode`与文件

![文件直接存放结构问题](.\素材\文件直接存放结构问题.png)

Q&A：以上创建的存储一个文件的简单数据结构，如何应对修改特别频繁的文件需求，如何优化数据结构管理更高效？

文件直接存放结构问题：需要连续空闲空间；文件数据修改不便；结构体体量过大。

#### 3.2.1 数据直接索引方式

![文件索引节点](.\素材\文件索引节点.png)

**`inode`结构，通过固定元数据+数据块索引方式管理文件的元数据+数据。**

Q&A：通过直接索引的方式管理数据块，当出现大文件时会有何问题？大文件小文件如何兼顾？

![文件直接索引结构大文件问题](.\素材\文件直接索引结构大文件问题.png)

#### 3.2.2 数据分级索引方式

![文件间接索引结构](.\素材\文件间接索引结构.png)

类似虚拟内存中提到的页表，在`inode`中采用分级的方式来组织存储块号。

#### 3.2.3 inode节点构成

![inode结构](.\素材\inode结构.png)

> 直接索引/一级索引/二级索引

`inode`中保存了三种存储指针（即存储设备的块号）：

1. 第— 种指针为直接指针，其直接指向数据块，数据块中保存了文件数据；
2. 第二种指针为间接指针，指向一个一级索引块，—级索引块中存放着指向数据块的指针；
3. 第三种指针为二级间接指针，指向—个二级索引块，二级索引块中的每个指针均指问一个一级索引块，进而指向多个数据块。

> 能表示的文件大小范围

我们之后均假设块大小为4KB，每个指针占据8个字节，每个`inode`中直接指针有12个，间接指针有3个，二级间接指针有1个。一个`inode`结构最大能表示多大的文件：

- 12个直接指针，每个指向4K，总共48K
- 每个指针8字节，索引块4K大小，总共有512个指针；一个索引块能表示4Kx512=2M数据，3个一级间接指针能表示3*2M=6M数据
- 1个二级间接指针，指向二级索引块，表示2M*512=1G数据
- 48K + 6M + 1G
- 多级指针比例是可调的，如果减少一个一级间接指针，增加一个三级指针呢？

> inode节点占用空间&索引占用空间

文件系统模块存放的时`inode`节点，也就是"元数据+指针"=128字节+128字节=256字节。

存满一个1G的文件，实际需要多大空间：

- `inode`结构体256字节
- 3个一级间接指针指向三个索引数据块：3*4K=12K
- 1个二级间接指针指向521个索引数据块：4K+512*4K=4K+2M
- 256字节+16K+2M+1G

> `inode`和内存页表有何相似之处？

如果我们把文件看成一个虚拟地扯空间（4GB的文件就是0～4GB的空间），把硬盘看作物理地址空间（4TB的硬盘就是0～4TB的空间），那么对文件某个偏移量的访问：首先需要将该偏移量翻译成硬盘空间的地址，这个过程与虚拟内存地址翻译的过程十分相似，而`inode`则担任了页表的角色，负责两个地址空间之间的映射。

> Ask Q1 Q2/Q3

> `EXT4`文件系统优化

使用`inode`结构存储满文件时，对于文件数据块是使用指针去索引的，**文件越大需要维护的数据块指针就越多**；以数据块为单位分块多级索引的方式也存在**数据存储分散导致随机访问性能下降**的问题。`EXT4`文件系统针对该情况设计了**区段树**。

![Ext4文件存储-区段树](.\素材\Ext4文件存储-区段树.png)

> 文件元数据信息

| **元数据字段**    | **描述**                                                     |
| :---------------- | :----------------------------------------------------------- |
| **i_mode**        | 文件类型（普通文件、目录等）及权限（rwx）。                  |
| **i_uid**         | 文件所有者的用户ID。                                         |
| **i_gid**         | 文件所属组的组ID。                                           |
| **i_size**        | 文件大小（字节）。                                           |
| **i_atime**       | 最后访问时间（Access Time）。                                |
| **i_mtime**       | 最后修改时间（Modify Time，指文件内容变更）。                |
| **i_ctime**       | 最后状态变更时间（Change Time，指元数据变更，如权限、链接数）。 |
| **i_links_count** | 硬链接计数（删除文件需此值为0）。                            |
| **i_blocks**      | 文件占用的磁盘块数（每块通常为4KB）。                        |
| **i_block[]**     | 数据块指针数组（直接块、间接块指针，用于定位文件内容）。     |
| **i_flags**       | 文件标志（如不可修改、压缩、加密等）。                       |
| **i_generation**  | 文件版本号（用于NFS等网络文件系统防重复）。                  |

> 文件类型

通过`i_mode`字段的高4位标识文件类型，常见类型如下：

| **文件类型**     | **标识符（宏）** | **说明**                                 |
| :--------------- | :--------------- | :--------------------------------------- |
| **普通文件**     | `S_IFREG`        | 文本、二进制等用户数据文件。             |
| **目录**         | `S_IFDIR`        | 包含子文件和子目录的特殊文件。           |
| **符号链接**     | `S_IFLNK`        | 指向其他文件路径的快捷方式。             |
| **字符设备文件** | `S_IFCHR`        | 提供流式访问的设备（如终端`/dev/tty`）。 |
| **块设备文件**   | `S_IFBLK`        | 提供块级访问的设备（如磁盘`/dev/sda`）。 |
| **管道（FIFO）** | `S_IFIFO`        | 进程间通信的命名管道。                   |
| **套接字**       | `S_IFSOCK`       | 网络通信的套接字文件。                   |

### 3.2 目录&文件

#### 3.2.1 文件名与目录

Q&A：文件系统管理文件时，需要文件名吗？

文件与`inode`是一一对应的，对于计算机程序来说，通过`inode`号就可以 找到对应的文件。`inode`编号是给操作系统看的，而文件名是给人看的。所以`inode`的元数据中**没有文件名**。

然而对于用户来说，使用`inode`号作为文件名并不合适。在文件系统中加入字符串形式的文件名，利用**目录**增加一层从文件名字符串到`inode`号之间的映射。

#### 3.2.2 重新认识“目录”

![目录tree结构](.\素材\目录tree结构.png)

#### 3.2.3 目录与文件的关系

目录是一种**特殊类型的文件**，用于记录其他文件和子目录的元数据（如名称、inode指针），形成树状层次结构。

文件名用于区分不同的文件，**保存在目录中**。就书籍的 “目录”—样，目录将文件名（对应书籍中各章节的标题）**组织**在—起，并且记录了每个文件名对应的**文件地址或者编号**（对应书籍中的页码）。每个文件名和对应的文件地址或编号组成一个**目录项**，一个或多个目录项组成一个目录。

**文件不是直接存放在目录中，而是把“文件名”、“文件地址”、“文件编号”组成目录项，存放在目录下。**

由于目录本身也是文件，因此可以通过**递归**的方式层次化地组织文件系统中的所有 文件。换句话说，目录与普通文件一样也有文件名，**其文件名保存在上一层目录文件中**； 上一层目录的文件名则保存在更上一层目录文件中，一直递归到最高一层目录——根目 录。**根目录没有文件名**，因为已经没有更上一层目录了。文件系统并不通过文件名来找到根目录，而是**将第一个`inode`作为根目录文件**。

#### 3.2.4 目录项结构

与常规文件中保存的用户数据不同，目录中保存的是—种特殊的结构──目录项。 每个目录项代表—条文件信息，记录了文件的文件名及其对应的`inode`号。

![目录项结构](.\素材\目录项结构.png)

一个目录项内的结构，包括文件名、文件名的长度、文件名对应的`inode`号和整个目录项的长度。

- 目录项长度记录整个目录项的长度，为目录项删除和重用而设计
- 文件名长度记录后面保存的文件名的有效长度

#### 3.2.5 目录下的文件操作

- 在目录中查找文件：在目录中查找某个文件名时，文件系统从目录文件的数据块中记录的第一个目录项开始依次比较，当某个目录项中的文件名与要查找的文件名相同时，返回对应的`inode`号。由于只需要查找当前目录保存的目录项，所以查找时间远小于遍历文件系统`inode`表的时间。 
- 遍历目录：与查找文件名的过程类似，文件系统找到该目录文件的数据块，依次检查保存的所有有效(还未被删除)的目录项，并返回结果。
- 删除目录项：文件系统首先在该目录中找到这个文件，然后从目录中删除对应的目录项。一种常见的实现方法是将目录项中的`inode`号设为0，表示该目录项是无效的。这种方法无须为目录有效性信息预留额外的存储空间，可以更高效地利用 空间。同时，删除后还可以将相邻的无效目录项进行合并，以允许更长的新目录项重新利用这些空间。
- 新增目录项：在目录中创建新文件时，文件系统会在该目录中增加一个新的目录项，记录新文件的文件名和对应的`inode`号。为优化存储空间，如果目录文件中有无效(已被删除)的目录项，且该目录项的空间足够保存新文件的文件名，则可以重用此目录项的位置存放新的目录项。如果找不到合适的无效目录项，则新的目录项会以追加的方式记录在目录文件末尾。

#### 3.2.6 一个文件可以有多个文件名

> 符号链接（软链接）

![软连接](.\素材\软链接.png)

> 硬连接

![硬链接](.\素材\硬链接.png)

### 3.3 文件描述符&打开文件&inode关系

![文件描述符&打开文件句柄&inode关系图](.\素材\文件描述符&打开文件句柄&inode关系图.png)

每一个文件描述符会与一个打开文件相对应，同时，不同的文件描述符也会指向同一个文件。相同的文件可以被不同的进程打开也可以在同一个进程中被多次打开。系统为每一个进程维护了一个文件描述符表，该表的值都是从0开始的，所以在不同的进程中你会看到相同的文件描述符，这种情况下相同文件描述符有可能指向同一个文件，也有可能指向不同的文件。

```c
/*
操作系统内核维护的数据结构
文件描述符（File Descriptor）-[进程级的文件描述符表]
打开文件表项（struct file）-[系统级的打开文件描述符表]
inode-[文件系统的inode表]
*/
```

### 3.4 文件系统存储布局

文件系统以特定的存储布局将文件数据和文件数据保存在存储设备之中。为了高效地管理这些文件数据和元数据，文件系统通常将存储空间划分成不同区域，分别用于不同功能。

> 总分区存储布局

![inode文件系统总分区存储布局](.\素材\inode文件系统总分区存储布局.png)

#### 3.4.1 基于`inode`文件系统的存储布局

![基于inode文件系统的存储布局](.\素材\基于inode文件系统的存储布局.png)

>  超级块

超级块位于文件系统的第一个存储块，负责记录整个文件系统的全局信息，主要包括其他区域在存储中的位置，即**每个区域开始的存储块号**。在真实的文件系统中，超级块通常还会包含用于**标识文件系统类型的魔数**、版本信息、**存储的空间大小**、**能支持的最大`inode`数量**、**当前空闲可用的`inode`的数量**、能支持的最大的块数量、**当前空闲可用的块数量**，以及一些统计信息，如最近一次的挂载 时间等。同时，由于超级块中包含的信息非常重要，通常会在存储设备的不同区域保存多个备份。

> 块分配信息

bitmap结构，用位图表示对应的节点是否使用

> `inode`分配信息

bitmap结构，用位图表示对应的节点是否使用

> inode节点表

保存所有的`inode`结构，由于`inode`表的区域不能动态调整，因此文件系统所能保存的最大文件数量在格式化的时候就已经确定了。

> 数据块

真正存储文件数据区域，不仅保存普通文件的数据，还会保存`inode`的索引块，以及目录的数据。

> 文件系统“额外消耗” Ask Q4

以上块信息中，数据块大小：4K * 234,159,616 = 937G

`inode`节点表：256B * 58,540,032 = 15G

`inode`分配信息：58,540,032 / 8 = 7.3M

块分配信息：234,159,616 / 8 = 29.3M

![硬盘缺斤少两答案](.\素材\硬盘缺斤少两答案.png)

## 4.基于TABLE的文件系统

### 4.1 FAT

文件分配表(File Allocation Table,FAT)是一种组织文件系统的架构，基于FAT的文件系统从早期FAT12、FAT16发展到现在被广泛应用的FAT32,和exFAT等文件系统。早期广泛应用于DOS、Windows 9x及嵌入式设备，至今仍被U盘、SD卡等移动存储设备广泛支持。其核心设计围绕**文件分配表**这一数据结构展开，具有结构简单、兼容性强的特点。下面基于FAT32为基础介绍FAT文件系统的基本设计。

#### 4.1.1 存储布局

![FAT存储布局](.\素材\FAT存储布局.png)

> 引导区

位于整个文件系统最前端的是引导记录。引导记录的作用**和超级块类似**，其中记录了**文件系统的元数据**（如簇大小、FAT表数量）以及**后续各个区域的位置**。若此分区是可启动分区，则引导记录中还包括引导整个操作系统启动所需要的代码。

> FAT1 FAT2

引导分区后通常为FAT，FAT通常有两份，两份FAT的内容一致，当FAT1由于各种原因损坏后，文件系统依然可以使用FAT2来访问和修复整个文件系统。

> 根文件夹 数据区

FAT后通常保存**根文件夹**（windows把目录称为文件夹），然后为数据区，保存其他文件夹和文件数据。

FAT文件 系统以**簇(Cluster)**作为逻辑存储单元（和“块”类似），每个簇对应物理存储上的一个或多个连续的存储扇区(Sector)(即存储设备的物理访问单元)。簇的具体大小可以在格式化时指定 （例如 512B, 1KB, 2KB, 4KB, 8KB, 16KB, 32KB, 64KB）。每个簇都有一个唯一的**逻辑簇号**，从 0 开始编号，直到卷的末尾。

#### 4.1.2 目录项结构

![FAT32的目录项结构](.\素材\FAT32的目录项结构.png)

FAT文件系统的目录项（Directory Entry）是文件与目录的元数据核心，每个目录项固定为**32字节**，用于描述文件/目录的基本信息。

重点关注条目信息：

- 文件名与扩展名（8+3格式），前八个字节存储文件名（短名），后三个字节固定存储文件后缀
- 属性：用来表示该目录项的种类和状态，属性分别用—个比特位表示：**位0**只读（read-only）、**位1**隐藏（hidden）、**位2**系统文件（system）、**位3**卷标（volume label）、**位4**子目录（subdirectory） 和**位5**存档（archive）。其中“卷标和子目录”两个比特位用于表示该目录项的种类。**值为“0x0F”表示长文件名目录项。**
- 起始簇号：**字节22-23**：起始簇号的高16位（仅FAT32使用，FAT12/16此处为保留字段）；**字节26-27**：起始簇号的低16位（FAT12/16直接使用，FAT32需与高16位组合为32位簇号）。
- 文件大小（32位无符号整数，单位字节），最大支持4GB（FAT32限制）

> 长文件名扩展（VFAT）

![FAT长目录项结构](.\素材\FAT长目录项结构.png)

- **实现方式**：通过多个连续的32字节目录项存储长文件名（Unicode编码），每个长文件名项属性标记为`0x0F`。
- 结构：**字节1-10**：长文件名第1-5个字符（UTF-16 LE编码）。**字节11**：属性（固定`0x0F`）。**字节12**：类型（保留为0）。**字节13**：校验和（用于关联长名与短名条目）。**字节14-25**：长文件名第6-11个字符。**字节26-27**：起始簇号（固定为0）。**字节28-31**：长文件名第12-13个字符。
- **规则**：长文件名项位于标准8.3目录项之前，按逆序排列。

文件名“The quick brown.fox”长文件存储

![FAT长文件名目录项存储](.\素材\FAT长文件名目录项存储.png)

#### 4.1.3 目录分配表FAT

FAT表本质上是一个**簇状态映射表**，每个表项对应一个簇，表项的值定义了该簇的状态（簇的好/坏状态、空闲状态等）或文件数据的链式关系（下一块文件数据所存放的簇号，值`FFFF`表示结尾）。

![FAT文件分配表](.\素材\FAT文件分配表.png)

> 文件的链表组织形式

![FAT文件的链表组织形式](.\素材\FAT文件的链表组织形式.png)

1. 根据目录项保存了首簇号
2. 获取簇号数据，接着读该簇号对应的FAT表项，获取下一个簇号
3. 重复步骤2，知道簇号对应的FAT表项值为“0x0FFFFFFF ”结束读取。

#### 4.1.4 优劣分析

- 相对`inode`索引文件数据方式，FAT将一个文件的多个数据簇以链表形式进行索引，结构简单额外空间消耗小，兼容性好
- 链表形式串联数据簇，导致大文件的随机读取效率低（需要一个块接一个块遍历读取）；链表结构脆弱，数据链损坏风险高，代价大；文件查找效率低
- 没有日志文件系统，无法做文件一致性保障；没有文件元数据；单文件大小限制4GB；分区上限2TB

#### 4.1.5 exFAT

FAT拓展版，核心改进包括：

- 突破文件大小限制，单文件理论支持16EB，分区上限达256TB
- 优化存储效率，簇大小灵活设置、使用位图加快空间分配、目录查找文件时使用哈希对比

### 4.2 NTFS

NTFS（New Technology File System）是在FAT文件系统之后，另一个在Windows操作系统中广泛使用（包括 Windows 2000, XP, Vista, 7, 8, 10, 11 及 Windows Server 系列）的文件系统。

> 物理磁盘与分区

NTFS 文件系统建立在一个**磁盘分区**上。分区可以是主分区、扩展分区或逻辑驱动器。物理磁盘被划分为固定大小的**扇区**（通常是 512 字节或 4K 字节）。这是磁盘 I/O 的最小单位。分区表（如 MBR 或 GPT）记录了分区在磁盘上的起始位置和大小。

分区表（Partition Table）是存储在**物理磁盘的最起始位置**的关键数据结构，它独立于任何操作系统和文件系统。在Windows系统中，当一块物理磁盘被划分为C、D、E、F等多个分区时，维护这些分区信息的分区表就位于**磁盘的第一个扇区（LBA 0）** 或**紧随其后保留扇区**中。

>  NTFS 卷 (NTFS Volume)

一个格式化成 NTFS 的分区就构成了一个 NTFS 卷，卷的逻辑地址空间被划分为连续的**逻辑簇号**。

#### 4.2.1 存储布局

![NTFS存储布局](.\素材\NTFS存储布局.png)

> 引导区

在卷的**最前几个扇区**（通常是 LCN 0）；内容包括引导代码（引导卷，用于加载操作系统启动文件）和BIOS参数块（该卷的基本属性信息,**文件系统引导扇区 BPB**也在其中）。

```c
#pragma pack(push, 1)
typedef struct _NTFS_BPB {
    // 标准 FAT BPB 字段
    UCHAR  JumpCode[3];      // 跳转指令（如 0xEB5290）
    CHAR   OemID[8];         // "NTFS    "
    USHORT BytesPerSector;   // 扇区大小（512/4096）
    UCHAR  SectorsPerCluster;// 每簇扇区数（簇大小=该值×扇区大小）
    // ... 其他 FAT 兼容字段省略 ...
    
    // NTFS 专属扩展字段
    ULONGLONG TotalSectors;      // 分区总扇区数
    ULONGLONG MftStartLcn;       // $MFT 的起始逻辑簇号（LCN）
    ULONGLONG MftMirrStartLcn;   // $MFTMirr 的起始 LCN
    CHAR   ClustersPerFileRecord; // 每 MFT 记录占用的簇数（通常=1）
    UCHAR  Reserved[3];
    CHAR   ClustersPerIndexBlock; // 每索引块占用的簇数（通常=1）
    UCHAR  Padding[3];
    ULONGLONG VolumeSerialNumber; // 卷序列号（64位随机值）
    ULONG  Checksum;             // BPB 校验和（NTFS 3.1+）
} NTFS_BPB;
#pragma pack(pop)
```

#### 4.2.2 主文件表MFT

主文件表 `$MFT`位于由 BPB 指定的起始`LCN `处，`$MFT` 本身是一个系统文件，由一系列固定大小的**记录**组成（通常是 1024 字节或 4096 字节，**卷上的每一个文件或目录（包括所有的系统元数据文件）都在 `$MFT` 中至少有一个对应的记录**（记录包含了描述该对象的所有**属性**） 。

MFT的内容(即MFT记录)保存在 一个名为`$MFT`的元数据文件中，**每条MFT记录都有一个唯一的编号**，从 0 开始，其中**前 16 条记录：** 通常保留给**关键的系统元数据文件**使用。

除了MFT中的前几条记录之外，其余记录可以分散存储在文件系统的各个位置，只要它们能够通过`$MFT`记录中保存的索引找到即可。但考虑到MFT需要被频繁访问，如果其存储过于分散，将影响对MFT的访问效率。因此，NTFS一般会预留整个文件系统存储空间的12.5%专门保存MFT的数据。

![MTF数据组成](.\素材\MTF数据组成.png)

##### 4.2.2.1 MFT保留记录

**MTF中的每一行对应着一个文件**，每一列为这个文件的某个元数据。MFT表由多条MFT记录组成，其中前16条为保留记录，称为元数据文件。元数据文件的文件名一般以`$`开头，其中保存了文件系统的元数据。

| MFT 记录号 | 文件名             | 作用描述                                                     | 是否必需 |
| :--------- | :----------------- | :----------------------------------------------------------- | :------- |
| **0**      | `$MFT`             | **主文件表自身**，描述自己的属性和数据位置                   | 必需     |
| **1**      | `$MFTMirr`         | MFT 前 4 条记录的镜像（备份），增强鲁棒性                    | 必需     |
| **2**      | `$LogFile`         | **事务日志文件**，记录元数据操作以保证崩溃恢复               | 必需     |
| **3**      | `$Volume`          | **卷元数据文件**，包含卷序列号、版本号、状态标志（如脏位）   | 必需     |
| **4**      | `$AttrDef`         | **属性定义表**，定义所有 NTFS 属性的类型、名称和规则         | 必需     |
| **5**      | `$Root`            | **根目录**，文件系统根路径 `\` 的目录索引                    | 必需     |
| **6**      | `$Bitmap`          | **簇分配位图文件**，每个比特表示卷上一个簇的占用状态（1=已用，0=空闲） | 必需     |
| **7**      | `$Boot`            | **引导文件**，存储引导代码和 BPB（位于物理扇区 0）           | 必需     |
| **8**      | `$BadClus`         | **坏簇记录文件**，标记卷上的损坏簇（避免分配）               | 必需     |
| **9**      | `$Secure`          | **安全描述符库**，集中存储唯一的安全描述符（避免重复）       | 必需     |
| **10**     | `$UpCase`          | **大写字符映射表**，用于文件名大小写不敏感比较               | 必需     |
| **11**     | `$Extend`          | **扩展元数据目录**，包含以下子文件                           | 必需     |
| **12**     | `$Extend\$ObjId`   | **对象 ID 文件**，存储文件对象 ID（GUID）与 MFT 记录的映射   | 可选     |
| **13**     | `$Extend\$Quota`   | **磁盘配额文件**，记录用户/组的磁盘使用限额                  | 可选     |
| **14**     | `$Extend\$Reparse` | **重解析点文件**，存储重解析点标签与数据                     | 可选     |
| **15**     | `$Extend\$UsnJrnl` | **更新序列号日志**，记录文件/目录的变更历史（如创建、修改）  | 可选     |

##### 4.2.2.2 MFT记录结构

MFT的每一行记录由记录头+多条属性组成。

![MFT记录](.\素材\MFT记录.png)

> 记录头结构

记录头固定为 **42字节**，关键字段如下：

| 偏移 | 长度 | 字段名                    | 作用说明                                                     |
| :--- | :--- | :------------------------ | :----------------------------------------------------------- |
| 0x00 | 4    | Signature (签名)          | 固定为 `FILE`（0x454C4946）表示有效记录；`BAAD` 表示损坏记录 |
| 0x04 | 2    | Update Offset (更新偏移)  | 更新序列数组的起始位置偏移量                                 |
| 0x06 | 2    | Update Size (更新大小)    | 更新序列数组的元素数量（包含自身）                           |
| 0x08 | 8    | $LogFile LSN              | 日志文件序列号（用于事务恢复）                               |
| 0x10 | 2    | Sequence Number (序号)    | 记录被重复使用时的递增序号（用于检测过时引用）               |
| 0x12 | 2    | Link Count (链接计数)     | 硬链接数量（删除文件时归零）                                 |
| 0x14 | 2    | **AttrOffset** (属性偏移) | **第一个属性的起始位置偏移量**（从记录头开始计算）           |
| 0x16 | 2    | Flags (标志位)            | 如 `0x01`=记录在使用中, `0x02`=是目录, `0x04`=扩展记录存在   |
| 0x18 | 4    | Bytes Used (已用字节)     | 记录实际使用的字节数（含头）                                 |
| 0x1C | 4    | Bytes Alloc (分配字节)    | 记录总分配字节数（通常=1024或4096）                          |
| 0x20 | 8    | BaseRecord (基记录)       | 扩展记录的基记录号（非扩展记录时为-1）                       |
| 0x28 | 2    | NextAttrID (下一属性ID)   | 分配给新属性的唯一ID（初始值=0，每新增属性+1）               |

- `AttrOffset` 指向第一个属性，从此位置开始解析属性列表。
- 若文件属性过多（或过大），会使用 `$ATTRIBUTE_LIST` 属性链接到扩展记录。

> 属性结构

**属性是 MFT 记录的核心内容**，文件的所有信息均直接或间接地以属性的形式保存在MFT记录中，分为 **属性头（Attribute Header）** 和 **属性体（Attribute Body）**。属性头是所有属性的共享部分，占用16字节。

每条属性中记录了属性类型、属性记录的长度、是否为常驻属性、属性名字和名字的长度、属性内容的长度、属性内容距离属性记录开头的偏移量以及变长的属性内容等信息。

![MFT记录属性结构](.\素材\MFT记录属性结构.png)

“常驻”：常驻/非常驻，其作用直接决定属性的存储策略，用来优化小文件/小文件夹的存储。

>  关键属性类型

| 类型代码 (Hex) | 属性名                  | 作用说明                                                     |
| :------------- | :---------------------- | :----------------------------------------------------------- |
| **0x10**       | `$STANDARD_INFORMATION` | 标准信息：时间戳（创建/修改）、文件属性（只读/隐藏）、所有者ID |
| **0x30**       | **`$FILE_NAME`**        | 文件名：文件名、父目录 MFT 记录号、时间戳（独立备份）        |
| **0x80**       | **`$DATA`**             | 文件数据：文件内容（主数据流或 ADS 流）                      |
| **0x90**       | **`$INDEX_ROOT`**       | 索引根：小型目录的索引树根节点（直接存储在 MFT 内）          |
| **0xA0**       | **`$INDEX_ALLOCATION`** | 索引分配：大型目录的索引树子节点（非驻属，存储在外部分配的簇中） |
| **0xB0**       | `$BITMAP`               | 位图：记录索引块（目录）或簇（`$Bitmap`文件）的使用状态      |
| **0xC0**       | `$REPARSE_POINT`        | 重解析点：用于符号链接、挂载点、文件系统扩展                 |
| **0x20**       | **`$ATTRIBUTE_LIST`**   | 属性列表：当属性无法全部放入一条 MFT 记录时，指向其他扩展记录 |

> 文件名结构

与inode文件系统中文件名只在目录的目录项中维护不一样，NTFS文件系统中文件名不仅在目录的目录项中存放，还会存放在文件的属性中。

文件名属性由通用属性头+文件属性头+文件名内容组成

![文件名结构](.\素材\文件名结构.png)

> MFT记录结构图

![MFT记录结构](.\素材\MFT记录结构.png)

#### 4.2.3 数据保存位置

NTFS根据文件/目录大小决定数据存放位置，常驻存储适用极小文件（通常<=600~800字节），文件内容/目录项直接嵌入其MTF记录内部；非常驻存储适用较大文件/较大目录，文件内容/目录项存储在独立的磁盘簇中。

##### 4.2.3.1 目录保存

> 目录常驻存储

**NTFS使用B+树管理目录项**，当目录中的目录项不多，可以被保存在索引根属性中时，该目录被称为常驻目录。常驻目录的索引根属性包括索引根的头部信息和若干索引记录（即目录项，**以文件名大写后的Unicode编码排序**）。

NTFS的目录项中主要保存文件名和MFT记录号，文件名保存在一个完整的文件名结构中，MFT记录号是指对应文件在MFT表中的编号，其作用与inode号相似。

**核心结构**：

- 目录内容存储在 **`$INDEX_ROOT` 属性**（常驻属性）。
- 索引以 **B+树根节点** 形式内嵌在 MFT 记录中（**单节点 B+树**，根节点即叶子节点）。

**数据布局**：

```c
MFT记录 {
  记录头;
  $INDEX_ROOT属性头 { 
    Non-Resident=0; 
    IndexType="文件名"; 
  };
  B+树根节点 {
    索引项1: "A.txt" → MFT引用
    索引项2: "B.log" → MFT引用
  };
}
```

`$INDEX_ROOT`索引根属性

![NTFS的目录索引根属性](.\素材\NTFS的目录索引根属性.png)

> 目录非常驻存储

当目录中的目录项多，索引根属性不足以存放时，该目录被称为非常驻目录。非常驻目录的索引根属性还是存放在属性`$INDEX_ROOT`中，索引块存放在`$INDEX_ALLOCATION`属性中，目录项存放在MFT记录外部簇流中。

**核心结构**：

- **`$INDEX_ROOT`**：存储 B+树 **根节点**（常驻）
- **`$INDEX_ALLOCATION`**：存储 **非根节点**（非常驻索引块）
- **`$BITMAP`**：管理索引块分配状态

**数据布局**：

```c
MFT记录 {
  记录头;
  $INDEX_ROOT { ... } // 常驻，含根节点
  $INDEX_ALLOCATION { // 非常驻
    Non-Resident=1;
    Runlist [ { LCN=5000, Length=50 } ]; // 索引块位置
  };
  $BITMAP { 0101... } // 标记索引块使用状态
}
```

**非常驻目录B+树存储结构图**

![NTFS非常驻目录B+树存储结构](.\素材\NTFS非常驻目录B+树存储结构.png)

##### 4.2.2.2 文件保存

文件保存使用`$DATA`属性保存，当文件内容小时是直接存放在`$DATA`属性中；当内容大时以多段簇流存放在外部数据区，其中`$DATA`的`RunList`存放各段簇流的起始偏移和长度信息。

案例：一个小型文本文件（内容为 "Hello"）

```plaintext
MFT 记录头 (42字节):
  签名: "FILE"
  属性偏移: 0x30 (48)
  标志: 0x01 (在用)
  属性1: $STANDARD_INFORMATION (常驻, 体大小=72字节)
  属性2: $FILE_NAME (常驻, 体大小=86字节)
  属性3: $DATA (常驻, 体大小=6字节)  -> 内容 "Hello"

属性3 ($DATA) 的详细结构:
  通用头:
    Type: 0x80 ($DATA)
    Length: 0x20 (32字节)
    Non-Resident: 0 (常驻)
    Body Size: 6 (内容长度)
    Body Offset: 0x18 (属性头后24字节)
  属性体: 48 65 6C 6C 6F 00 ("Hello" + 结束符)
```

案例：一个大型文件（数据非驻属）

```plaintext
属性: $DATA (类型0x80)
  通用头:
    Non-Resident: 1 (非常驻)
  非驻属头:
    Start VCN: 0
    End VCN: 15  (文件占16个簇)
    Runlist Offset: 0x40 (64)
    Runlist: [LCN=1000, 长度=8] [LCN=2000, 长度=8]  -> 数据存储在2个连续块中
```

![NTFS文件非常驻存储](.\素材\NTFS文件非常驻存储.png)

#### 4.2.4 对比优势

Q&A：为什么NTFS存取小文件很高效？

Q&A：为什么NTFS存取大文件很高效？

Q&A：对比inode和FAT，NTFS根据文件名查找文件的效率如何？

## 5.虚拟文件系统VFS

### 5.1 问题背景

**如何在一个系统中同时支持多个文件系统？**

>  异构的文件系统

计算机系统中可能同时存在多种文件系统。例如，在同一台计算机中，用户分别使 用NTFS和Ext4两个文件系统管理一块机械硬盘上的不同区域，用于保存电影和数据备 份。同时，在一块固态硬盘中，用户使用Ext4文件系统保存系统文件和频繁使用的数 据。当在不同的计算机系统之间传递数据时，用户还经常将FAT32文件系统格式的USB 闪存盘接入计算机系统。

![多种文件系统并存](.\素材\多种文件系统并存.png)

>  屏蔽文件系统的异构性

**中间层，对上提供POSIX API，对下对接不同的文件系统驱动**

在操作系统中，虚拟文件系统(Virtual File System, VFS)对多种文件系统进行管理和协调，允许它们在同一个操作系统上共同工作。不同文件系统在存储设备上使用不同的数据结构和方法保存文件。为了让这些文件系统工作在同一个操作系统之上，VFS定义了 一系列内存数据结构，并要求底层不同的文件系统提供指定的方法，将其存储设备上的元数据统一转换为VFS的内存数据结构，VFS通过这些内存数据结构向上为应用程序提供统一的文件系统服务。

![增加一层VFS承上启下](.\素材\增加一层VFS承上启下.png)

### 5.2 VFS实现

#### 5.2.1 文件系统挂载

文件系统通过挂载的方式接入到VFS中

| ![VFS-挂载前](.\素材\VFS-挂载前.png) | ![VFS-挂载后](.\素材\VFS-挂载后.png) |
| ------------------------------------ | ------------------------------------ |

#### 5.2.2 抽象层

>  操作系统层面

VFS定义操作&管理文件的接口

![VFS定义的inode操作接口](.\素材\VFS定义的inode操作接口.png)

> 文件系统驱动软件层面

文件系统驱动软件实现VFS接口，进行“翻译”，操作硬件

![VFS实现-Ext4文件系统](.\素材\VFS实现-Ext4文件系统.png)

![VFS-FAT接入面临问题](.\素材\VFS-FAT接入面临问题.png)

>  VFS，对文件系统中多种结构在内存中映射

![文件系统在内存中映射](.\素材\文件系统在内存中映射.png)

### 5.3 页缓存

存储访问非常耗

文件访问具有时间局部性

![页缓存工作原理](.\素材\页缓存工作原理.png)

## 结尾

参考资料url

https://ipads.se.sjtu.edu.cn/ospi/

https://ycnw11in464y.feishu.cn/file/IO2QbAiMFo0XnWx0lqyc9DaunBe

https://ycnw11in464y.feishu.cn/file/SXm8bcUrIobU3bxLWY4cpmn7n66

https://ipads.se.sjtu.edu.cn/courses/os/2020/slides/OS-12-fs.pdf

https://blog.csdn.net/cywosp/article/details/38965239
